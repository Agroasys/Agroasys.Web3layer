services:
  postgres:
    image: postgres:16-alpine
    profiles: ["local-dev", "staging-e2e", "infra"]
    environment:
      POSTGRES_USER: "${POSTGRES_USER}"
      POSTGRES_PASSWORD: "${POSTGRES_PASSWORD}"
      POSTGRES_DB: "${POSTGRES_DB}"
    volumes:
      - postgres-data:/var/lib/postgresql/data
      - ./postgres/init/10-service-databases.sql:/docker-entrypoint-initdb.d/10-service-databases.sql:ro
    ports:
      - "${POSTGRES_PORT:-5432}:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER}"]
      interval: 10s
      timeout: 5s
      retries: 5

  redis:
    image: redis:7-alpine
    profiles: ["local-dev", "staging-e2e", "infra"]
    command: ["redis-server", "--appendonly", "yes"]
    volumes:
      - redis-data:/data
    ports:
      - "${REDIS_PORT:-6379}:6379"
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5

  indexer:
    image: node:20-alpine
    profiles: ["local-dev"]
    command:
      - node
      - -e
      - |
        const http = require('http');
        const payload = JSON.stringify({ data: { trades: [] } });

        http.createServer((req, res) => {
          if (req.url !== '/graphql' || req.method !== 'POST') {
            res.statusCode = 404;
            res.end('not found');
            return;
          }

          req.on('data', () => {
            // request body intentionally ignored in lightweight local responder
          });

          req.on('end', () => {
            res.setHeader('Content-Type', 'application/json');
            res.end(payload);
          });
        }).listen(4350, '0.0.0.0');
    healthcheck:
      test:
        - CMD
        - node
        - -e
        - |
          fetch('http://127.0.0.1:4350/graphql', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ query: 'query { __typename }' }),
          })
            .then((response) => process.exit(response.ok ? 0 : 1))
            .catch(() => process.exit(1));
      interval: 10s
      timeout: 5s
      retries: 5

  indexer-migrate:
    profiles: ["staging-e2e"]
    build:
      context: .
      dockerfile: indexer/Dockerfile
    environment:
      DB_HOST: postgres
      DB_PORT: "5432"
      DB_NAME: "${INDEXER_DB_NAME}"
      DB_USER: "${POSTGRES_USER}"
      DB_PASSWORD: "${POSTGRES_PASSWORD}"
    depends_on:
      postgres:
        condition: service_healthy
    command: ["npx", "squid-typeorm-migration", "apply"]

  indexer-pipeline:
    profiles: ["staging-e2e"]
    build:
      context: .
      dockerfile: indexer/Dockerfile
    environment:
      DB_HOST: postgres
      DB_PORT: "5432"
      DB_NAME: "${INDEXER_DB_NAME}"
      DB_USER: "${POSTGRES_USER}"
      DB_PASSWORD: "${POSTGRES_PASSWORD}"
      GATEWAY_URL: "${INDEXER_GATEWAY_URL}"
      RPC_ENDPOINT: "${INDEXER_RPC_ENDPOINT}"
      START_BLOCK: "${INDEXER_START_BLOCK}"
      RATE_LIMIT: "${INDEXER_RATE_LIMIT}"
      CONTRACT_ADDRESS: "${INDEXER_CONTRACT_ADDRESS}"
      GRAPHQL_PORT: "${INDEXER_GRAPHQL_PORT}"
    depends_on:
      postgres:
        condition: service_healthy
      indexer-migrate:
        condition: service_completed_successfully
    healthcheck:
      test: ["CMD-SHELL", "ps aux | grep -q '[l]ib/main.js'"]
      interval: 15s
      timeout: 5s
      retries: 5

  indexer-graphql:
    profiles: ["staging-e2e"]
    build:
      context: .
      dockerfile: indexer/Dockerfile
    environment:
      DB_HOST: postgres
      DB_PORT: "5432"
      DB_NAME: "${INDEXER_DB_NAME}"
      DB_USER: "${POSTGRES_USER}"
      DB_PASSWORD: "${POSTGRES_PASSWORD}"
      GQL_PORT: "${INDEXER_GRAPHQL_PORT}"
    depends_on:
      postgres:
        condition: service_healthy
      indexer-migrate:
        condition: service_completed_successfully
    command: ["npx", "squid-graphql-server"]
    ports:
      - "${INDEXER_GRAPHQL_PORT:-4350}:${INDEXER_GRAPHQL_PORT:-4350}"
    healthcheck:
      test:
        - CMD
        - node
        - -e
        - |
          const p = process.env.GQL_PORT || '4350';
          fetch('http://127.0.0.1:' + p + '/graphql', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ query: '{ __typename }' }),
          })
            .then((response) => process.exit(response.ok ? 0 : 1))
            .catch(() => process.exit(1));
      interval: 10s
      timeout: 5s
      retries: 8

  ricardian:
    profiles: ["local-dev", "staging-e2e"]
    build:
      context: .
      dockerfile: ricardian/Dockerfile
    environment:
      PORT: "${RICARDIAN_PORT}"
      DB_HOST: postgres
      DB_PORT: "5432"
      DB_NAME: "${RICARDIAN_DB_NAME}"
      DB_USER: "${POSTGRES_USER}"
      DB_PASSWORD: "${POSTGRES_PASSWORD}"
      AUTH_ENABLED: "${RICARDIAN_AUTH_ENABLED}"
      API_KEYS_JSON: "${RICARDIAN_API_KEYS_JSON}"
      AUTH_MAX_SKEW_SECONDS: "${RICARDIAN_AUTH_MAX_SKEW_SECONDS}"
      AUTH_NONCE_TTL_SECONDS: "${RICARDIAN_AUTH_NONCE_TTL_SECONDS}"
      RATE_LIMIT_ENABLED: "${RICARDIAN_RATE_LIMIT_ENABLED}"
      RATE_LIMIT_REDIS_URL: "${RICARDIAN_RATE_LIMIT_REDIS_URL}"
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    ports:
      - "${RICARDIAN_PORT:-3100}:${RICARDIAN_PORT:-3100}"

  treasury:
    profiles: ["local-dev", "staging-e2e"]
    build:
      context: .
      dockerfile: treasury/Dockerfile
    environment:
      PORT: "${TREASURY_PORT}"
      DB_HOST: postgres
      DB_PORT: "5432"
      DB_NAME: "${TREASURY_DB_NAME}"
      DB_USER: "${POSTGRES_USER}"
      DB_PASSWORD: "${POSTGRES_PASSWORD}"
      INDEXER_GRAPHQL_URL: "${TREASURY_INDEXER_GRAPHQL_URL}"
      TREASURY_INGEST_BATCH_SIZE: "${TREASURY_INGEST_BATCH_SIZE}"
      TREASURY_INGEST_MAX_EVENTS: "${TREASURY_INGEST_MAX_EVENTS}"
      AUTH_ENABLED: "${TREASURY_AUTH_ENABLED}"
      API_KEYS_JSON: "${TREASURY_API_KEYS_JSON}"
      AUTH_MAX_SKEW_SECONDS: "${TREASURY_AUTH_MAX_SKEW_SECONDS}"
      AUTH_NONCE_TTL_SECONDS: "${TREASURY_AUTH_NONCE_TTL_SECONDS}"
    depends_on:
      postgres:
        condition: service_healthy
      indexer:
        condition: service_healthy
        required: false
      indexer-graphql:
        condition: service_healthy
        required: false
    ports:
      - "${TREASURY_PORT:-3200}:${TREASURY_PORT:-3200}"

  oracle:
    profiles: ["local-dev", "staging-e2e"]
    build:
      context: .
      dockerfile: oracle/Dockerfile
    environment:
      PORT: "${ORACLE_PORT}"
      API_KEY: "${ORACLE_API_KEY}"
      HMAC_SECRET: "${ORACLE_HMAC_SECRET}"
      RPC_URL: "${ORACLE_RPC_URL}"
      CHAIN_ID: "${ORACLE_CHAIN_ID}"
      ESCROW_ADDRESS: "${ORACLE_ESCROW_ADDRESS}"
      USDC_ADDRESS: "${ORACLE_USDC_ADDRESS}"
      ORACLE_PRIVATE_KEY: "${ORACLE_PRIVATE_KEY}"
      DB_HOST: postgres
      DB_PORT: "5432"
      DB_NAME: "${ORACLE_DB_NAME}"
      DB_USER: "${POSTGRES_USER}"
      DB_PASSWORD: "${POSTGRES_PASSWORD}"
      INDEXER_GRAPHQL_URL: "${ORACLE_INDEXER_GRAPHQL_URL}"
      RETRY_ATTEMPTS: "${ORACLE_RETRY_ATTEMPTS}"
      RETRY_DELAY: "${ORACLE_RETRY_DELAY}"
      NOTIFICATIONS_ENABLED: "${ORACLE_NOTIFICATIONS_ENABLED}"
      NOTIFICATIONS_WEBHOOK_URL: "${ORACLE_NOTIFICATIONS_WEBHOOK_URL}"
      NOTIFICATIONS_COOLDOWN_MS: "${ORACLE_NOTIFICATIONS_COOLDOWN_MS}"
      NOTIFICATIONS_REQUEST_TIMEOUT_MS: "${ORACLE_NOTIFICATIONS_REQUEST_TIMEOUT_MS}"
    depends_on:
      postgres:
        condition: service_healthy
      indexer:
        condition: service_healthy
        required: false
      indexer-graphql:
        condition: service_healthy
        required: false
    ports:
      - "${ORACLE_PORT:-3001}:${ORACLE_PORT:-3001}"
    healthcheck:
      test:
        - CMD
        - node
        - -e
        - |
          const p = process.env.PORT || '3001';
          fetch('http://127.0.0.1:' + p + '/api/oracle/health')
            .then((response) => process.exit(response.ok ? 0 : 1))
            .catch(() => process.exit(1));
      interval: 10s
      timeout: 5s
      retries: 8

  reconciliation:
    profiles: ["local-dev", "staging-e2e"]
    build:
      context: .
      dockerfile: reconciliation/Dockerfile
    environment:
      RECONCILIATION_ENABLED: "${RECONCILIATION_ENABLED}"
      RECONCILIATION_DAEMON_INTERVAL_MS: "${RECONCILIATION_DAEMON_INTERVAL_MS}"
      RECONCILIATION_BATCH_SIZE: "${RECONCILIATION_BATCH_SIZE}"
      RECONCILIATION_MAX_TRADES_PER_RUN: "${RECONCILIATION_MAX_TRADES_PER_RUN}"
      DB_HOST: postgres
      DB_PORT: "5432"
      DB_NAME: "${RECONCILIATION_DB_NAME}"
      DB_USER: "${POSTGRES_USER}"
      DB_PASSWORD: "${POSTGRES_PASSWORD}"
      RPC_URL: "${RECONCILIATION_RPC_URL}"
      CHAIN_ID: "${RECONCILIATION_CHAIN_ID}"
      ESCROW_ADDRESS: "${RECONCILIATION_ESCROW_ADDRESS}"
      USDC_ADDRESS: "${RECONCILIATION_USDC_ADDRESS}"
      INDEXER_GRAPHQL_URL: "${RECONCILIATION_INDEXER_GRAPHQL_URL}"
      NOTIFICATIONS_ENABLED: "${RECONCILIATION_NOTIFICATIONS_ENABLED}"
      NOTIFICATIONS_WEBHOOK_URL: "${RECONCILIATION_NOTIFICATIONS_WEBHOOK_URL}"
      NOTIFICATIONS_COOLDOWN_MS: "${RECONCILIATION_NOTIFICATIONS_COOLDOWN_MS}"
      NOTIFICATIONS_REQUEST_TIMEOUT_MS: "${RECONCILIATION_NOTIFICATIONS_REQUEST_TIMEOUT_MS}"
    depends_on:
      postgres:
        condition: service_healthy
      indexer:
        condition: service_healthy
        required: false
      indexer-graphql:
        condition: service_healthy
        required: false

volumes:
  postgres-data:
  redis-data:
